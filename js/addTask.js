/**
 * Initializes the task creation process by including HTML, fetching contacts from remote storage, 
 * loading tasks from remote storage, rendering the add task HTML, and checking the validity of the task.
 *
 * @return {Promise<void>} Promise that resolves when the initialization is complete.
 */
async function addTaskInit(){
    includeHTML();
    await getContactsFromRemoteStorage();
    getContactsOutOfUsers();
    await loadTasksFromRemoteStorage();
    renderAddTaskHTML();
    checkValidity();
}

function callAddTaskModuleMethod(moduleName, methodName, args = [], fallbackValue) {
    const moduleRef = window[moduleName];
    if (!moduleRef || typeof moduleRef[methodName] !== "function") {
        return fallbackValue;
    }
    return moduleRef[methodName](...args);
}


/**
 * Renders the HTML for adding a task.
 *
 */
function renderAddTaskHTML() {
    let container = document.getElementById('addTaskBody');
    container.innerHTML = '';
    container.innerHTML += renderAddTaskMainContentHTML();
    document.getElementById('addTaskBodyRight').innerHTML = renderAddTaskFooterHTML();
    registerAddTaskKeyboardAccessibility();
    initializeDropdownAccessibilityState();
    setTodayDateAsMin();
    setPriority('medium');
    renderContactsToDropdown();
    renderSubtasks();
    if (typeof initializeFilepickerUI === "function") {
        initializeFilepickerUI();
    }
  }



/**
 * Updates the priority styling for the task buttons based on the selected priority.
 *
 * @param {string} priority - The selected priority ('Urgent', 'Medium', or 'Low').
 */
function setPriority(priority) {
    setPriorityAppearance(priority);
    setPriorityForNewCard(priority);
}


/**
 * Updates the appearance of the priority buttons based on the selected priority.
 *
 * @param {string} priority - The selected priority ('Urgent', 'Medium', or 'Low').
 */
function setPriorityAppearance(priority){
    document.querySelectorAll('.addTaskPriorityButton').forEach(button => {
        button.style.backgroundColor = 'white';
        button.classList.remove('active');
        button.querySelector('.priorityButtonText').style.color = 'black';
        button.querySelector('img').src = `./assets/img/icon-priority_${button.id.toLowerCase().slice(21)}.png`;
    });

    const button = document.getElementById(`addTaskPriorityButton${priority}`);
    button.style.backgroundColor = getButtonColor(priority);
    button.classList.add('active');
    button.querySelector('.priorityButtonText').style.color = 'white';
    button.querySelector('img').src = `./assets/img/icon-priority_${priority.toLowerCase()}_white.png`;
}


/**
 * Renders the subtask input field by setting the innerHTML of the 'subtaskBottom' element to the HTML code 
 * generated by the 'renderSubtaskInputFieldHTML' function. Then, sets the focus on the 'subtaskInputField' element.
 */
function renderSubtaskInputField(){
    let subtaskBottom = document.getElementById('subtaskBottom');
    subtaskBottom.innerHTML = renderSubtaskInputFieldHTML();
    document.getElementById('subtaskInputField').focus();
}


/**
 * Handles adding or canceling a subtask based on the option provided.
 *
 * @param {string} option - The option to add or cancel a subtask.
 */
function subtaskAddOrCancel(option) {
    let subtaskBottom = document.getElementById('subtaskBottom');
    let subtaskInputField = document.getElementById('subtaskInputField');
    if (option == 'add') {
        if (subtaskInputField.value != '') {
            addSubtask();
        }
    }
    subtaskBottom.innerHTML = renderSubtaskDefaultHTML();
    subtaskBottom.dataset.action = 'render-subtask-input-field';
}


/**
 * Renders the subtasks by iterating through each subtask and calling the renderSubtaskHTML function.
 */
function renderSubtasks(){
    let outputContainer = document.getElementById('subtasksOutputContainer');
    outputContainer.innerHTML = '';
    for (let i = 0; i < newTask.subtasks.length; i++) {
        let subtask = newTask.subtasks[i];
        renderSubtaskHTML(outputContainer, subtask);
    }
}


/**
 * Checks if any subtask container has the 'editing' class.
 * This is to prevent other subtasks to be edited.
 *
 * @return {boolean} Returns true if any subtask container has the 'editing' class, otherwise returns false.
 */
function checkIfAnySubtaskIsInEditingMode(){
    let subtaskContainers = document.getElementsByClassName('subTaskOutputDiv');
    for (let i = 0; i < subtaskContainers.length; i++) {
        let subtaskContainer = subtaskContainers[i];
        if (subtaskContainer.classList.contains('editing')) {
            return true;
        }
    }
    return false;
}


/**
 * Returns the background color for a given priority level.
 *
 * @param {string} priority - The priority level ('urgent', 'medium', or 'low').
 * @return {string} The corresponding background color ('red', 'orange', 'green', or 'white').
 */
function getButtonColor(priority) {
    switch (priority) {
        case 'urgent':
            return '#ff3d00';
        case 'medium':
            return '#ffa800';
        case 'low':
            return '#7ae229';
        default:
            return 'white';
    }
}


/**
 * Toggles the visibility of the dropdown content and updates the arrow image based on its current direction.
 */
function renderArrow(arrowContainer, contentContainer){
    registerAddTaskKeyboardAccessibility();
    callAddTaskModuleMethod(
        "AddTaskDropdown",
        "renderArrow",
        [arrowContainer, contentContainer],
        undefined
    );
}


/**
 * Opens a dropdown and stores opener metadata for focus restoration.
 *
 * @param {string} arrowContainerId - Arrow container id.
 * @param {string} contentContainerId - Dropdown content id.
 * @returns {void}
 */
function openDropdown(arrowContainerId, contentContainerId){
    callAddTaskModuleMethod(
        "AddTaskDropdown",
        "openDropdown",
        [arrowContainerId, contentContainerId],
        undefined
    );
}


/**
 * Closes a specific dropdown by its content id.
 *
 * @param {string} contentContainerId - Dropdown content id.
 * @param {{restoreFocus?: boolean}} [options={}] - Close behavior options.
 * @returns {boolean} True when a dropdown was closed.
 */
function closeDropdown(contentContainerId, options = {}){
    return callAddTaskModuleMethod(
        "AddTaskDropdown",
        "closeDropdown",
        [contentContainerId, options],
        false
    );
}


/**
 * Closes all currently open dropdowns.
 *
 * @param {{restoreFocus?: boolean}} [options={}] - Close behavior options.
 * @returns {boolean} True when at least one dropdown was closed.
 */
function closeOpenDropdowns(options = {}){
    return callAddTaskModuleMethod(
        "AddTaskDropdown",
        "closeOpenDropdowns",
        [options],
        false
    );
}


/**
 * Sets base ARIA state for dropdown trigger buttons.
 *
 * @returns {void}
 */
function initializeDropdownAccessibilityState(){
    callAddTaskModuleMethod(
        "AddTaskDropdown",
        "initializeDropdownAccessibilityState",
        [],
        undefined
    );
}


/**
 * Registers keyboard handling for dropdown Escape-close behavior.
 *
 * @returns {void}
 */
function registerAddTaskKeyboardAccessibility(){
    callAddTaskModuleMethod(
        "AddTaskKeyboard",
        "registerAddTaskKeyboardAccessibility",
        [],
        undefined
    );
}


/**
 * Handles Escape key presses for dropdown close flows.
 *
 * @param {KeyboardEvent} event - Keyboard event.
 * @returns {void}
 */
function handleAddTaskKeyboardAccessibility(event){
    callAddTaskModuleMethod(
        "AddTaskKeyboard",
        "handleAddTaskKeyboardAccessibility",
        [event],
        undefined
    );
}


/**
 * Focuses the first focusable control inside a dropdown panel.
 *
 * @param {HTMLElement} dropdownContainer - Open dropdown container.
 * @returns {void}
 */
function focusFirstDropdownControl(dropdownContainer){
    callAddTaskModuleMethod(
        "AddTaskDropdown",
        "focusFirstDropdownControl",
        [dropdownContainer],
        undefined
    );
}


/**
 * Sets delegated close behavior for outside container based on the open dropdowns.
 *
 * @return {void}
 */
function setCloseDropdownContainer(){
    callAddTaskModuleMethod(
        "AddTaskDropdown",
        "setCloseDropdownContainer",
        [],
        undefined
    );
}


/**
 * Returns the container element to set delegated dropdown-close action on.
 *
 * @return {HTMLElement} Container used for outside-click dropdown close behavior.
 */
function getContainerToSetDropdownCloseAction(){
    return callAddTaskModuleMethod(
        "AddTaskDropdown",
        "getContainerToSetDropdownCloseAction",
        [],
        null
    );
}


/**
 * Renders the test contacts in the dropdown content.
 */
function renderContactsToDropdown(){
    let content = document.getElementById('dropdown-content-assignedTo');
    content.innerHTML = '';
    contacts.forEach(contact => {
        const safeContactId = toSafeInteger(contact && contact.id);
        const safeContactName = escapeHtml(contact && contact.name);

        content.innerHTML += /*html*/`<button type="button" class="dropdownOption" id="assignedToContact${safeContactId}" marked=false data-action="assign-contact-to-task" data-contact-id="${safeContactId}">
            <span class="dropdownContactBadgeAndName">${renderAssignedToButtonsHTML(contact)} ${safeContactName}</span> <img src="./assets/img/icon-check_button_unchecked.png" alt="">
            </button>`
    })
}


/**
 * Opens the calendar picker for the due date input field.
 *
 */
function addTaskDueDateOpenCalendear(){
    document.getElementById('addTaskDueDateInput').showPicker();
}

/**
 * Sets the appearance of the dropdown contact based on the 'marked' attribute.
 *
 * @param {Element} dropdownContact - The dropdown contact element to modify.
 * @param {Element} dropdownCheckboxImage - The image element representing the checkbox.
 */
function setDropdownContactAppearance(dropdownContact, dropdownCheckboxImage){
    if (dropdownContact.getAttribute('marked') == 'false'){
        dropdownContact.setAttribute('marked', 'true');
        dropdownCheckboxImage.src = './assets/img/icon-check_button_checked_white.png';
    }else{
        dropdownContact.setAttribute('marked', 'false');
        dropdownCheckboxImage.src = './assets/img/icon-check_button_unchecked.png';
    }
}


/**
 * Toggles the visibility of the assigned contacts container based on the marked attribute of the contact cards.
 */
function toggleAssignedContactsContainer(){
    let contactCards = document.getElementById('dropdown-content-assignedTo').childNodes;
    let assignedContactsContainer = document.getElementById('assignedContactsContainer');
    let empty = true;
    for(let i = 0; i < contactCards.length; i++){
        if(contactCards[i].getAttribute('marked') == 'true'){
            assignedContactsContainer.classList.remove('d-none');
            empty = false;
            break;
        }
    }
    if (empty){
        assignedContactsContainer.classList.add('d-none');
    }
}


/**
 * Renders the assigned contacts container by populating it with the HTML generated by the renderAssignedToButtonsHTML function.
 */
function renderAssignedContactsContainer(){
    let container = document.getElementById('assignedContactsContainer');
    container.innerHTML = '';
    tempAssignedContacts.forEach(id => {
        let contact = contacts.find(contact => contact.id == id);
        container.innerHTML += renderAssignedToButtonsHTML(contact)
    })
}


/**
 * Updates the category elements with the chosen category and hides the dropdown content.
 *
 * @param {string} chosenCategory - The selected category.
 * @return {void} 
 */
function chooseCategory(chosenCategory){
    let categoryContainer = document.getElementById('dropdown-category-title');
    categoryContainer.innerHTML = chosenCategory;
    closeDropdown('dropdown-content-category', { restoreFocus: true });
    setCloseDropdownContainer();
    newTask['type'] = chosenCategory;
}


/**
 * Checks if any card is currently being edited.
 *
 * @return {boolean} Returns true if a card is being edited, false otherwise.
 */
function checkIfCardIsEditing(){
    let editing = document.getElementsByTagName('*');
    for (let element of editing){
        if(element.hasAttribute('editing')){
            return true;
        }
    }
    return false;
}


/**
 * Sets the minimum value of the "addTaskDueDateInput" element to the current date.
 */
function setTodayDateAsMin(){
    callAddTaskModuleMethod(
        "AddTaskFormDomain",
        "setTodayDateAsMin",
        [],
        undefined
    );
}


/**
 * Check the validity of required input fields and toggle the required message accordingly.
 *
 */
function checkValidity(){
    callAddTaskModuleMethod(
        "AddTaskFormDomain",
        "checkValidity",
        [],
        undefined
    );
}


/**
 * A function to get the state of a required field.
 *
 * @param {Object} requiredInputField - The required input field object to check.
 * @return {boolean} Returns true if the field is not empty, false otherwise.
 */
function getStateOfRequriredField(requiredInputField){
    return callAddTaskModuleMethod(
        "AddTaskFormDomain",
        "getStateOfRequriredField",
        [requiredInputField],
        false
    );
}


/**
 * Sets the state of the create button based on the state of required input fields.
 */
function setCreateBtnState() {
	callAddTaskModuleMethod(
        "AddTaskFormDomain",
        "setCreateBtnState",
        [],
        undefined
    );
}


/**
 * Activates a button by removing the disabled state and wiring its delegated click action.
 *
 * @param {string} id - The ID of the button element.
 * @param {string} actionName - The data-action value handled by delegated events.
 */
function activateButton(id, actionName){
    callAddTaskModuleMethod(
        "AddTaskFormDomain",
        "activateButton",
        [id, actionName],
        undefined
    );
}


/**
 * Deactivates a button by adding the disabled state and removing delegated action wiring.
 *
 * @param {string} id - The ID of the button element.
 */
function deactivateButton(id){
    callAddTaskModuleMethod(
        "AddTaskFormDomain",
        "deactivateButton",
        [id],
        undefined
    );
}
